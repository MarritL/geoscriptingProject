---
title: "Explaining roe deer movement in the Italian alps"
authors: Anne-Juul Welsink and Marrit Leenstra
date: 31 January 2019
output: html_notebook
---

TODO:
Project description

```{r}
# check if libraries are installed
if (!require("dplyr")) install.packages("dplyr")
if (!require("sp")) install.packages("sp")
if (!require("sf")) install.packages("sf")
if (!require("DBI")) install.packages("DBI")
if (!require("RSQLite")) install.packages("RSQLite")
if (!require("raster")) install.packages("raster")
if (!require("adehabitatLT")) install.packages("adehabitatLT")
if (!require("lubridate")) install.packages("lubridate")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("gridExtra")) install.packages("gridExtra")
if (!require("leaflet")) install.packages("leaflet")
if (!require("rlist")) install.packages("rlist")
if (!require("entropy")) install.packages("entropy")
```

```{r}
# load libraries
library(dplyr)
library(sp)
library(sf)
library(DBI)
library(raster)
library(adehabitatLT)
library(lubridate)
library(ggplot2)
library(gridExtra)
library(leaflet)
library(rlist)
library(entropy)
```

```{r}
# import functions
source("R/retrieveData.R")
source("R/saveDataInDB.R")
source("R/simulateMovement.R")
source("R/createSpatialLine.R")
source("R/extractRasterValues.R")
```

```{r}
# project variables

# downloadlinks
movementDataURL = "extras.springer.com/2014/978-3-319-03742-4/trackingDB_datasets.zip"
environmentalURL = "https://drive.google.com/uc?export=download&id=1rX-R5sjqPbX2Z5xvDyZVM-l4RdRYA4HV"

# projections
proj4WGS84 <- "+proj=longlat +datum=WGS84 +no_defs"
proj4zone32 <- "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs"
proj4Mercator <- "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"
```

```{r}
# download movement data
folder = "data"
retrieveData(movementDataURL, folder)

# download environmental data
retrieveData(environmentalURL, folder)
```

```{r}
# Load environmental data to global environment
DEM <- raster(list.files(path = "data/GoogleEarthData", pattern = glob2rx('*DEM*.tif'), full.names = TRUE))
landsat <- brick(list.files(path = "data/GoogleEarthData", pattern = glob2rx('*Landsat*.tif'), full.names = TRUE))
landUse <- raster(list.files(path = "data/GoogleEarthData", pattern = glob2rx('*LandUse*.tif'), full.names = TRUE))
slope <- raster(list.files(path = "data/GoogleEarthData", pattern = glob2rx('*Slope*.tif'), full.names = TRUE))
```

We use an example dataset of roe deer movement from a book about spatial database management (Urbano and Cagnacci, 2014). The data are thus designed for use in a database and set up as interlinking datasets. Direct use in R is possible, but undesirable due to a lack of structure. Therefore, we set up an SQLite database in memory to process the data.

```{r}
# create database connection
movementDB <- dbConnect(RSQLite::SQLite(), "")

# get files
gpsData <- list.files(path = "data/tracking_db/data/sensors_data/", pattern = glob2rx('GSM0*.csv'), full.names = TRUE)
sensorsAnimals <- list.files(path = "data/tracking_db/data/sensors_animals/", pattern = glob2rx('*.csv'), full.names = TRUE)
sensors <- list.files(path = "data/tracking_db/data/sensors/", pattern = glob2rx('*.csv'), full.names = TRUE)
animals <- list.files(path = "data/tracking_db/data/animals/", pattern = glob2rx('*.csv'), full.names = TRUE)

# specify column names for database tables
gpsDataColumnNames <- c("gpsSensorsCode","lineNo", "utcDate", "utcTime", "lmtDate", "lmtTime", "ecefX", "ecefY","ecefZ", "latitude", "longitude", 
"height", "dop", "nav", "validated", "satsUsed", "ch01SatId", "ch01SatCnr", "ch02SatId", "ch02SatCnr", "ch03SatId", "ch03SatCnr", "ch04SatId", "ch04SatCnr", "ch05SatId", "ch05SatCnr", "ch06SatId", "ch06SatCnr", "ch07SatId", "ch07SatCnr", "ch08SatId", "ch08SatCnr", "ch09SatId", "ch09SatCnr", "ch10SatId", "ch10SatCnr", "ch11SatId", "ch11SatCnr", "ch12SatId", "ch12SatCnr", "mainVol", "buVol", "temp", "easting", "northing", "remarks")
sensorsAnimalsColumnNames <- c("animalsId","gpsSensorsId","startTime","EndTime","notes")
sensorsColumnNames <-c("gpsSensorsId", "gpsSensorsCode", "purchaseDate", "frequency", "vendor","model","sim")
animalsColumnNames <- c("animalsId", "animalsCode", "name","sex","ageClassCode", "speciesCode")

# save data in database
saveDataInDB(gpsData, movementDB, "gpsData", gpsDataColumnNames, TRUE)
saveDataInDB(sensorsAnimals, movementDB, "sensorsAnimals", sensorsAnimalsColumnNames, FALSE)
saveDataInDB(sensors, movementDB, "sensors", sensorsColumnNames, FALSE)
saveDataInDB(animals, movementDB, "animals", animalsColumnNames, FALSE)
```

The database can be queried with SQL. Since we want to link the GPS data with specific animals we need to join these tables. However, these tables do not have any common fields that can be used for a straightforward join. Embedding of SQL statements allows us to get to the required combination of data. 

```{r}
# query data from database
query <- '
SELECT
animals.name,
animals.sex,
dataWithAnimalId.utcDate, dataWithAnimalId.utcTime, 
dataWithAnimalId.latitude, dataWithAnimalId.longitude,
dataWithAnimalId.height
FROM
  (SELECT 
  dataWithSensorId.gpsSensorsCode, 
  dataWithSensorId.utcDate, dataWithSensorId.utcTime, 
  dataWithSensorId.latitude, dataWithSensorId.longitude, 
  dataWithSensorId.height,
  dataWithSensorId.gpsSensorsId, 
  sensorsAnimals.animalsId 
  FROM 
    (SELECT 
    gpsData.gpsSensorsCode, 
    gpsData.utcDate, gpsData.utcTime, 
    gpsData.latitude, gpsData.longitude, 
    gpsData.height,
    sensors.gpsSensorsId 
    FROM 
    gpsData 
    LEFT JOIN 
    sensors ON gpsData.gpsSensorsCode = sensors.gpsSensorsCode) AS dataWithSensorId 
  LEFT JOIN 
  sensorsAnimals ON dataWithSensorId.gpsSensorsId = sensorsAnimals.gpsSensorsId) AS dataWithAnimalId 
LEFT JOIN
animals ON dataWithAnimalId.animalsId = animals.animalsId
;'

selectedMovementData <- dbGetQuery(movementDB, query)
```

At this point we have the data we need. However, all data is stored as strings. The correct classes are assigned, before we can create a geometry out of the latitude and longitude columns. We choose the WGS84 zone 32 (EPSG:32632) as coordinate system as it provides enough detail for our analyses. 

```{r}
# correct classes
selectedMovementData$sex <- factor(selectedMovementData$sex)
class(selectedMovementData$latitude) <- "numeric"
class(selectedMovementData$longitude) <- "numeric"
class(selectedMovementData$height) <- "numeric"
selectedMovementData$date <- dmy_hms(paste(selectedMovementData$utcDate, selectedMovementData$utcTime), tz = "UTC")
# remove redundant columns
selectedMovementData[3:4] <- list(NULL)

# remove rows with NA for location
selectedMovementDataNoNA <- selectedMovementData[!is.na(selectedMovementData$latitude) | !is.na(selectedMovementData$longitude),]

# create spatial data frame projected in WGS84 zone 32
coords <- selectedMovementDataNoNA[,c(4:3)]
WGS84movementSDF <- SpatialPointsDataFrame(coords = coords, data = selectedMovementDataNoNA, proj4string = CRS(proj4WGS84))
movementSDF <- spTransform(WGS84movementSDF, CRS(proj4zone32))

# create trajectories
movementTrajectories <- as.ltraj(xy = coordinates(movementSDF), date = movementSDF$date, id = movementSDF$name)
```

We are curious where "our" roe deer are going! 

```{r}
# check data
plot(DEM)
lines(movementTrajectories[[1]])
lines(movementTrajectories[[2]], col = 'red')
lines(movementTrajectories[[3]], col = 'blue')
lines(movementTrajectories[[4]], col = 'purple')
lines(movementTrajectories[[5]], col = 'orange')
```

Oops! The data clearly contain some outliers. These need to be removed in order to perform reliable analyses. We look at boxplots of the different variables to find the best variables to remove these outliers. 

```{r}
# cast back to dataframe
dataframeTrajectories <- ld(movementTrajectories)
groups <- dataframeTrajectories %>% mutate(height = movementSDF$height) %>% group_by(id)
trajectories <- dl(groups)

#plot
p1 <- ggplot(groups, aes(x=id, y=x, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("x-coordinates of locations")
p2 <- ggplot(groups, aes(x=id, y=y, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("y-coordinates of locations")
p3 <- ggplot(groups, aes(x=id, y=dist, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Distance between relocations")
p4 <- ggplot(groups, aes(x=id, y=abs.angle, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Absolute angle between relocations")
p5 <- ggplot(groups, aes(x=id, y=rel.angle, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Relative angle between relocations")
p6 <- ggplot(groups, aes(x=id, y=dt, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Time between relocations")

grid.arrange(p1,p2,p3,p4,p5,p6, layout_matrix = rbind(c(1,2),c(3,4),c(5,6)))
```

These boxplots show the outliers very clearly in the x and y-coordinates as well as the distance and time between relocations. In previous steps we removed some measurements with NA's for latitude and longitude to be able to convert the dataframe to a spatial dataframe. As a result, the time between relocations is not 100% accurate. We will therefore use only x-coordinates, y-coordinates and distance between relations to clean our dataset. Tresholds for the x and y-coordinates are based purely on these boxplots. To determine the treshold for the distance we take a look at the distribution of steplengths. 

```{r}
par(mfrow=c(3, 2))
for (i in 1:length(id(movementTrajectories))){
  hist(movementTrajectories[[i]]$dist, xlim = c(0, 5000), ylim = c(0, 1500), breaks = seq(0, 1000000, by = 100), xlab = "distance (m)", main = paste("Distance between relocations by", id(movementTrajectories)[i]))
}
```
Looking at the distribution of steplengths and taking into account the consideration that roe deer generally do not travel great distances, a moved distance of 1500m or higher in one relocation is considered unrealistic. 

```{r}
# tresholds
xMin <- 650000
xMax <- 700000
yMin <- 5092500
yMax <- 5107500
distMax <- 1500

# remove outliers based on x-coordinates and distance between relocations
groupsCleaned <- groups %>% filter(x < xMax) %>% filter(x > xMin) %>% filter(y < yMax) %>% filter(y > yMin) %>% filter(dist < distMax)

# cast back to ltraj 
movementTrajectoriesCleaned <- dl(groupsCleaned)
```

```{r}
# check data again
plot(DEM)
lines(movementTrajectoriesCleaned[[1]])
lines(movementTrajectoriesCleaned[[2]], col = 'red')
lines(movementTrajectoriesCleaned[[3]], col = 'blue')
lines(movementTrajectoriesCleaned[[4]], col = 'purple')
lines(movementTrajectoriesCleaned[[5]], col = 'orange')

# boxplots
p1 <- ggplot(groupsCleaned, aes(x=id, y=x, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("x-coordinates of locations")
p2 <- ggplot(groupsCleaned, aes(x=id, y=y, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("y-coordinates of locations")
p3 <- ggplot(groupsCleaned, aes(x=id, y=dist, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Distance between relocations")
p4 <- ggplot(groupsCleaned, aes(x=id, y=abs.angle, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Absolute angle between relocations")
p5 <- ggplot(groupsCleaned, aes(x=id, y=rel.angle, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Relative angle between relocations")
p6 <- ggplot(groupsCleaned, aes(x=id, y=dt, fill = id)) + geom_boxplot(alpha=0.2) + theme(legend.position = "none") + ggtitle("Time between relocations")

grid.arrange(p1,p2,p3,p4,p5,p6, layout_matrix = rbind(c(1,2),c(3,4),c(5,6)))
```

The data is ready for the analyses!

Before we start our movement analysis, we will first have a look at the reliability of our data.
The altitude measurement of the GPS data needs to be validated through a comparison with the DEM. GPS data are not reliable if its mean altitude differs significantly from the DEM values at corresponding spatial points. A paired t-test is performed to assess the reliability the measurements.
```{r}
# Calculate DEM height values at point locations for which GPS height data is available.
heightDEM <- extract(DEM, as.data.frame(groupsCleaned[,c("x","y")]), method='simple', na.rm=TRUE, df=TRUE)
heightDEM$animal <- unlist(groupsCleaned[,"id"])
colnames(heightDEM) <- c("ID", "rasterVal", "animal")

heightData <- data.frame(group = rep(c("DEM", "GPS"), each = nrow(heightDEM)), height = c(heightDEM$rasterVal, groupsCleaned$height))

# Perform a paired t-test to compare mean GPS and DEM height
tTest <- t.test(heightDEM$rasterVal, groupsCleaned$height, paired = TRUE, alternative = "two.sided")
print("Results of the paired t-test:")
tTest

#Visualize
boxplot(height ~ group, heightData, main = "Height boxplot GPS and DEM", ylab = "Height")

```

The paired t-test confirmed that there is a significant difference (p-value < 2.2e-16) in mean altitude between the GPS height measurement and the DEM height values. The mean difference between the two measurements amounts to 41 meters. As shown in the boxplot, the GPS data contains large outliers (the alps are not 20 000 in height!). This confirms our suspicion that the GPS altitude measurements are not always reliable. Therefore, we will use DEM altitude measurement for our further analysis.  

```{r}
# number of simulations per animal
nSimulations <- 2   

# perform simulations
simulations <- simulateMovement(trajectories = movementTrajectoriesCleaned, nSimulations = nSimulations, proj4 = proj4zone32)

# plot example
plot(DEM)
lines(simulations[[1]][[1]][[1]])
```

```{r}
# select distinct animals
animalNames <- distinct(groupsCleaned, id)[[1]]

for (animal in animalNames){
  # get location data from nth animal
  locationdata <- groupsCleaned[(groupsCleaned$id == animal),]
  
  # create spatial line
  assign(paste0("traject",animal), createSpatialLine(locationdata = locationdata, proj4dataframe = proj4zone32, proj4line = proj4WGS84, lineId = animal))
}

```

Visualize using leaflet
```{r}
m <- leaflet() %>% 
  setView(lng=11.0367, lat=46.0331, zoom = 11) %>%
  # Baselayers
  addTiles(group = 'Street map') %>%  
  addProviderTiles('Stamen.Terrain', group = 'Terrain') %>% 
  addProviderTiles('Esri.WorldImagery', group = 'Satellite') %>%
  # Overlay groups
  addPolylines(data = trajectAgostino, weight = 1, opacity = 0.8, color = "red", group = 'Agostino') %>% 
  addPolylines(data = trajectAlessandra, weight = 1, opacity = 0.8, color = "blue", group = 'Alessandra') %>% 
  addPolylines(data = trajectDaniela, weight = 1, opacity = 0.8, color = "orange", group = 'Daniela') %>% 
  addPolylines(data = trajectDecimo, weight = 1, opacity = 0.8, color = "yellow", group = 'Decimo') %>% 
  addPolylines(data = trajectSandro, weight = 1, opacity = 0.8, color = "purple", group = 'Sandro') %>% 
  addLayersControl(
    baseGroups = c('Street map', 'Terrain', 'Satellite'),
    overlayGroups = c('Agostino', 'Alessandra', 'Daniela', 'Decimo', 'Sandro'),
    options = layersControlOptions(collapsed = FALSE)
  )
m 
```

```{r}
# Extract altitude values of simulations from DEM. 
simulationElevations <- extractRasterValues(DEM, simulations)
simulationLandUse <- extractRasterValues(landUse, simulations)
plotProfiles(simulationElevations, heightDEM)
```

```{r}

#heightDEM <- extract(DEM, as.data.frame(groupsCleaned[,c("x","y")]), method='simple', na.rm=TRUE, df=TRUE)
#heightDEM$animal <- unlist(groupsCleaned[,"id"])
# animalSimEl <- simulationElevations %>% filter(animal = animalNames[animalname])

animalNames <- unique(heightDEM$animal)

for (animal in 1:length(animalNames)){
    print(animal)
    # filter elevation data per animal from simulations
    animalEl <- heightDEM %>% filter(animal == animalNames[animal])
    
    simulationElevations[[animal]] <- cbind(simulationElevations[[animal]], animalEl$rasterVal)
}    
  
boxplot.matrix(simulationElevations[[1]], use.cols = TRUE)
test3 <- stack(as.data.frame(simulationElevations[[1]])) # add colnames
ggplot(test3) +
geom_boxplot(aes(x = ind, y = values))
```

```{r}
simAgostino <- simulationElevations[simulationElevations$animal == 'Agostino',]
DEMAgostino <- heightDEM[heightDEM$animal == 'Agostino',]

# Entropy returns an estimate of the Shannon entropy.
entropySimAgostino <- entropy(simAgostino$rasterVal, method = "ML", unit = "log2")
print(paste("The entropy of the simulated altitude for", as.character(simAgostino$animal[1]), "is: ", entropySimAgostino))

entropyDEMAgostino <- entropy(DEMAgostino$rasterVal, method = "ML", unit = "log2")
print(paste("The entropy of the recorded altitude for", as.character(DEMAgostino$animal[1]), "is: ", entropyDEMAgostino))


```

```{r}
# disconnect database
dbDisconnect(movementDB)
```

## References
Urbano, F., & Cagnacci, F. (2014). Spatial database for GPS wildlife tracking data. Springer International Publishing.